# {{name}}

{{description}}

Version: {{version}}

[![Pub Package](https://img.shields.io/pub/v/smart_parser.svg)](https://pub.dev/packages/smart_parser)
[![GitHub Issues](https://img.shields.io/github/issues/mezoni/smart_parser.svg)](https://github.com/mezoni/smart_parser/issues)
[![GitHub Forks](https://img.shields.io/github/forks/mezoni/smart_parser.svg)](https://github.com/mezoni/smart_parser/forks)
[![GitHub Stars](https://img.shields.io/github/stars/mezoni/v.svg)](https://github.com/mezoni/smart_parser/stargazers)
[![GitHub License](https://img.shields.io/badge/License-BSD_3--Clause-blue.svg)](https://raw.githubusercontent.com/mezoni/smart_parser/main/LICENSE)

## About this software

This software is a library that generates source code of recursive descent parsers based on a grammar consisting of the parsing expressions and native Dart language source code.  
Productions are generated as functions, and expressions are generated as statements.  

The expression generator generates source code in several stages.  
In the first stage, a states is generated from expressions.  
In the second stage, parsing code generators are created for expressions within the states.  
In the third stage, the state machine is built, and as each individual state is built, the production code is filled with expression code, in accordance with the order of the corresponding state events.

This approach allows for the generation of more efficient parsing algorithms.  
In particular, the advantages are as follows:

- The number of variables (RHS) used is reduced
- The number of direct uses of values (LHS), including constant values, increases
- The efficiency of control transfer increases

As a result, the output (parsing source code) is the same algorithms that can be written manually or generated by a regular generator, but with some degree of optimization due to the use of a state machine.

An example of transferring control using the `return` statement.

```dart
START
`int` ABC =>
  [a] / [b] / [c]
END
```

An example of transferring control using the labeled `break` statements.

```dart
START
`(int, int)` ABC =>
  ab = ([a] / [b])
  c = [c]
  $ = { (ab, c) }
END
```

An example of transferring control using the `continue` statements.

```dart
START
`List<int>` AB =>
  $ = ([a] / [b])+
END
```

## Practical use

The grammar is simple and intuitive. Understanding the grammar should not be difficult.  
The quality of the generated code is quite acceptable.  
The performance of the generated parsers is quite good.  
All of the above allows this software to be used for the implementation of practical applications, including the tokenizers and real-time parsers (such as `JSON`, `CSV`, `XML` and others).  

The planned feature is to generate a parsers that parses the tokenized input produced by the tokenizers.

Example of parsing a C escape sequence (partially).

```dart
START
`String` Escape =>
  "n"
  $ = `const` { '\n' }
  ----
  "r"
  $ = `const` { '\r' }
  ----
  "t"
  $ = `const` { '\t' }
END
```

Example of punctuation token generation.

The generator does not analyze the code into actions, but the source code of the action must have balanced pairs of `{` and `}` characters, and for this reason these characters are presented in a different form.

```dart
START
`Token` Punctuation =>
  { final start = state.position; }
  ","
  $ = { _token(start, state.position, ",", tokenKind.comma) }
  ----
  "}"
  $ = { _token(start, state.position, "\u007B", tokenKind.openBrace) }
  ----
  "{"
  $ = { _token(start, state.position, "\u007D", tokenKind.closeBrace) }
  ----
  ":"
  $ = { _token(start, state.position, ":", tokenKind.colon) }
  ----
  "=>"
  $ = { _token(start, state.position, "=>", tokenKind.rightArrow) }
END
```

Example of identifier token generation.

```dart
START
`String` Identifier =>
  # !keyword
  !(
    # keywords
    (
      "foreach"
      ---
      "for"
    )
    # !identifier cont.
    ! [a-zA-Z0-9]
  )
  # identifier
  $ = <
    [a-zA-Z]
    [a-zA-Z0-9]*
  >
END
```

In practice, this algorithm works quite quickly.  
Although this is not the fastest parsing method in the world, but it is simple and understandable.

## Grammar

Grammar declaration is made using sections, like sections for a preprocessor, but at the same time, it should be noted that preprocessing is not performed and grammar processing (parsing) occurs in one stage.

3 sections are used to declare the grammar:

- Section for declaring directives and global members
- Section for declaring members of instances of the parser class
- Section for declaring grammar rules

Example of a grammar declaration:

```txt
%{
import 'foo.dart';
}%

%%
const SimpleParser();
%%

AZ => [A-Za-z]*
```

The grammar must contain at least one production rule, which means that using a section to declare grammar rules is mandatory. The use of other sections is optional and is determined by the actual needs based on the chosen method of declaring the grammar.

## Generating the parser source code

The parser source code is generated using the `ParserGenerator` class.

An example of generating parser source code.

```dart
import 'dart:io';

import 'package:smart_parser/parser_generator.dart';

void main(List<String> args) {
  const inputFile = 'lib/src/smart_parser/smart_parser.grammar';
  const outputFile = 'lib/src/smart_parser/smart_parser.dart';
  final source = File(inputFile).readAsStringSync();
  final options = ParserGeneratorOptions(name: 'SmartParser');
  final parserGenerator = ParserGenerator(options: options, source: source);
  final output = parserGenerator.generate();
  File(outputFile).writeAsStringSync(output);
  Process.runSync(Platform.executable, ['format', outputFile]);
}
```

## Error handling system

The error handling system is based on the recommendation of Brian Ford, who introduced `PEG`.  

> Though there is probably no perfect method of deciding exactly what information is
the “most relevant” to an error, a simple heuristic that provides good results in practice is
simply to prefer information produced at positions farthest to the right in the input stream.  
> -- Brian Ford

This means that everything that has been successfully parsed is considered valid input data.  
However, this method does not in any way determine how exactly to generate errors.  
This method only offers a way to determine the location of the most relevant error.  

The error handling system used in this software classifies parsing failures into two types:

- Failure
- Error

The difference between an error and a failure is that an error is a failure with additional information about the cause of the failure.  
This, in turn, means that failure can be detected automatically, while errors must be generated explicitly.

For this purpose, the ability to define error handlers and error generation procedures is provided.  
An error handler can be defined at the end of a `Sequence` expression using the  `~{}` notation.

Example of an error handler.

```dart
START
`Expression` Expression =>
  Additional
  ~ {
    state.removeRecentErrors();
    state.errorExpected('expression');
  }
END
```

The following procedures are available for generating errors:

- `state.error()`
- `state.errorExpected()`
- `state.errorIncorrect()`

A procedure `state.removeRecentErrors()` is also available. It removes the recent errors generated at the starting position of the parsing `Sequence` expression.

Example of  `state.errorIncorrect()` procedure.

```dart
START
`int` HexValue =>
  n = <
    @while (4, 4) {
      Hex
    }
  >
  $ = { int.parse(n, radix: 16) }
  ~ {
    state.errorExpected('hex number');
    state.errorIncorrect('Invalid four-digit number', true);
  }
END
```

## Expressions

The following parsing expressions are supported:

- AnyCharacter
- AndPredicate
- CharacterClass
- Group
- Literal
- NotPredicate
- OneOrMore
- Optional
- OrderedChoice
- Sequence
- ZeroOrMore

Detailed information about these expressions can be obtained from the following sources:

- [Parsing expression grammar](https://en.wikipedia.org/wiki/Parsing_expression_grammar)
- [Parsing Expression Grammars: A Recognition-Based Syntactic Foundation](https://bford.info/pub/lang/peg)

Further in the text, the above expressions will be described only as examples of generated code or with a description of features applicable to this software.

The following additional parsing expressions are supported:

- Action
- Capture
- Predicate

The following parsing meta-expressions are supported:

- @position
- @while

Additional features:

- Semantic values

## Expression `AnyCharacter`

The `AnyCharacter` expression `.` is a parsing expression that matches any single character.  
The `AnyCharacter` expression does not add any errors to the error buffer.

```dart
START
`int` AnyCharacter =>
  .
END
```

```dart
START
`void` AnyCharacter =>
  .
END
```

Example of the expression `eof`.

```dart
START
`void` Eof =>
  ! .
END
```

Another example of the expression `eof`.

```dart
START
`void` Eof =>
  & { state.peek() < 0 }
END
```

## Expression `AndPredicate`

The `AndPredicate` expression `&e` invokes the sub-expression `e`, and then succeeds if `e` succeeds and fails if `e` fails, but in either case never consumes any input.

Example with single branch.

```dart
START
`String` AndPredicate =>
  $ = <[a-zA-Z]>
  &"=>"
END
```

## Expression `CharacterClass`

The `CharacterClass` expression `[]` is a parsing expression that matches a character.  
The `CharacterClass` expression does not add any errors to the error buffer.

The following forms of character specifiers are supported:

- Single character in natural form, eg. `[a]`
- Multiple character ranges in natural form, eg. `[a-z]`, `[0-9]`
- Single character in hexadecimal form, eg. `[\u{20}]`
- Multiple character ranges in hexadecimal form, eg. `[\u{30}-\u{39}]`
- C-escape sequences, eg. `[\n\r\t]`
- Escaping special characters: `\\`, `^`, `-`, `[`, `]`, eg. `[\^]`, `[\]]`
- Matching characters with negation in all available forms, eg. `[^a-z]`, `[^\u{20}]`

Examples of single character.

```dart
START
`int` A =>
  [a]
END
```

```dart
START
`void` A =>
  [a]
END
```

Examples of character range.

```dart
START
`int` Digits =>
  [0-9]
END
```

Examples of negated character range.

```dart
START
`int` NotDigits =>
  [^0-9]
END
```

Examples of negated character ranges.

```dart
START
`int` NotDigitsNotLetters =>
  [^0-9a-zA-Z]
END
```

Examples of hexadecimal value.

```dart
START
`int` Space =>
  [\\u{20}]
END
```

Examples of hexadecimal range.

```dart
START
`int` Digits =>
  [\\u{30}-\\u{39}]
END
```

## Expression `Group`

The `Group` expression groups expressions into a single expression.

⚠ Important information:  
For performance reasons, the `Group` expression does not create a separate naming scope.  
Thus, conflicts of names of semantic values are possible.  
To avoid duplicate name conflicts, it is necessary to use different semantic value identifiers within a scope.

Example of a `Group` expression at the end of a `Sequence` expression.

```dart
START
`int` AB =>
  [a]
  $ = ([b] / [c])
END
```

Example of a `Group` expression not at the end of a `Sequence` expression.

```dart
START
`(int, int)` AB =>
  $ = ([b] / [c])
  [a]
END
```

## Expression `Literal`

The `Literal` expression is a parsing expression that matches a string.

The `Literal` expression can be specified in both regular and extended forms.  
A `Literal` expression in its normal form is specified using double quotes `""` its expanded form is specified using single quotes `''`.

The difference between the normal form and the extended form is that in the latter case the `expected` error is added to the error buffer.

Examples of regular form.

```dart
START
`String` For =>
  "for"
END
```

```dart
START
`void` For =>
  "for"
END
```

Examples of extended form.

```dart
START
`String` For =>
  'for'
END
```

```dart
START
`void` For =>
  'for'
END
```

Example of parsing an empty string.

```dart
START
`void` EmptyString =>
  ""
END
```

## Expression `NotPredicate`

The `NotPredicate` expression `!e` invokes the sub-expression `e`, and then succeeds if `e` fails and fails if `e` succeeds, but in either case never consumes any input.

Example with a child expression with single branch.

```dart
START
`void` NotPredicate =>
  ! [a]
END
```

Example with a child expression with multiple branches.

```dart
START
`void` NotPredicate =>
  !([a] / [b])
END
```

## Expression `OneOrMore`

The `OneOrMore` expression `e+` matches a sequence of one or more repetitions of a sub-expression `e`.

Examples with a child expression with single branch.

```dart
START
`List<int>` OneOrMore =>
  [a]+
END
```

```dart
START
`void` OneOrMore =>
  [a]+
END
```

Examples with a child expression with multiple branches.

```dart
START
`List<int>` OneOrMore =>
  ([a] / [b])+
END
```

```dart
START
`void` OneOrMore =>
  ([a] / [b])+
END
```

## Expression `Optional`

The `Optional` expression `e?` matches zero or one expression `e`, and then succeeds with or without result.

Example with single branch.

```dart
START
`int?` Optional =>
  [a]?
END
```

```dart
START
`void` Optional =>
  [a]?
END
```

Example with multiple branches.

```dart
START
`int?` Optional =>
  ([a] / [b])?
END
```

```dart
START
`void` Optional =>
  ([a] / [b])?
END
```

Example with `Production` expression.

```dart
START
`int?` Optional =>
  P?
END
```

```dart
START
`int?` Optional =>
  p = P?
  $ = { p ?? 41 }
END
```

```dart
START
`void` Optional =>
  P?
END
```

## Expression `OrderedChoice`

The `OrderedChoice` expression has the following syntax.

`e1 / e2`

Where `e1` and `e2` are alternative expressions.  
If the first alternative successfully parses the input, it is accepted. If it fails, the parser then attempts the next alternative, and so on, until a match is found or all alternatives have been exhausted.

Examples of the `OrderedChoice` expression.

```dart
START
`int` AOrB =>
  [a]
  /
  [b]
END
```

```dart
START
`void` AOrB =>
  [a]
  /
  [b]
END
```

Examples using alternative syntax.

```dart
START
`int` AOrB =>
  [a]
  ----
  [b]
END
```

```dart
START
`void` AOrB =>
  [a]
  ----
  [b]
END
```

## Expression `Sequence`

The `Sequence` expression `e1 e2` first invokes `e1`, and if `e1` succeeds, subsequently invokes `e2` on the remainder of the input data left unconsumed by `e1`, and returns the result. If either `e1` or `e2` fails, then the sequence expression `e1 e2` fails (consuming no input).

Examples of the `Sequence` expression.

```dart
START
`(int, int)` AB =>
  a = [a]
  b = [b]
  $ = `const` { (a, b) }
END
```

```dart
START
`void` AB =>
  [a]
  [b]
END
```

## Expression `ZeroOrMore`

The `ZeroOrMore` expression `e*` matches a sequence of zero or more repetitions of a sub-expression `e`.

Examples with a child expression with single branch.

```dart
START
`List<int>` OneOrMore =>
  [a]*
END
```

```dart
START
`void` OneOrMore =>
  [a]*
END
```

Examples with a child expression with multiple branches.

```dart
START
`List<int>` OneOrMore =>
  ([a] / [b])*
END
```

```dart
START
`void` OneOrMore =>
  ([a] / [b])*
END
```

## Expression `Action`

The `Action` expression `{ }` is a piece of code, that always succeeds, with or without a result, depending on how it is used.

The following usage methods are supported:

- List of statements
- Expression
- Sub-expression

⚠ Important information:

- Changing the parsing `position` in the action code is prohibited. This will cause the parser to malfunction. For this case, there is a meta expression `@position`
- The source code must have balanced pairs of `{` and `}` characters. Unbalanced characters should be presented in a different form, eg. '\\u007B'

Example with a list of statements.

```dart
START
`List<int>` Action =>
  {
    final list = [];
    list.add(41);
  }
  $ = { list }
END
```

The first action (without assigning semantic value) is the method used to define a `list of statements`.  
The second action (with assignment of semantic value) is the method used to define an `expression`.  

That is, if the action is used with the assignment of semantic value then it is a method used to define an expression, otherwise for defining statements.

In all cases, the expression completes parsing successfully.

Example with sub-expression.

```dart
START
`void` Action =>
  & { some_expression }
END
```

## Expression `Capture`

The `Capture` expression `<e>` invokes the expression `e`, and then succeeds if the expression `e` succeeds, and fails otherwise. If successful, the substring of the input data from the beginning to the end of the expression `e` is returned.

Examples of the `Capture` expression.

```dart
START
`String` Digits =>
  <[0-9]+>
END
```

```dart
START
`void` SkipDigits =>
  <[0-9]+>
END
```

## Expression `Predicate`

The `Predicate` expression `&{}` invokes the action `{}`, and then succeeds if the action code evaluates to `true`, and fails otherwise, without consuming any input.

The `Predicate` expression `!{}` invokes the action `{}`, and then succeeds if the action code evaluates to `false`, and fails otherwise, without consuming any input.

Example of positive predicate.

```dart
START
`void` Action =>
  & { some_expression }
END
```

Example of negative predicate.

```dart
START
`void` Action =>
  ! { some_expression }
END
```

## Meta expression `@position`

The `Position` expression `@position(n)` changes the parsing position to `n`, then succeeds and returns `n`.

Example of input data scanning.

```dart
START
`String` EndTag =>
  { final index = state.indexOf('-->'); }
  @position({ index != -1 ? index : state.length })
  $ = '-->'
END
```

## Meta expression `@while`

The `@while` meta expression is a repetition expression and works similarly to the `while` statement.  
A slight difference is that this expression takes two positional parameters, `m` and `n`.  
The first parameter `m` is required and specifies the minimum number of repetitions.  
The second parameter `n` is optional and specifies the maximum number of repetitions.  
If the `n` parameter is not specified, the number of repetitions is unlimited.  

Examples of repetitions from 0 and no limit on the maximum number of repetitions.

```dart
START
`List<int>` Letters =>
  @while (0) {
    [a-zA-Z]
  }
END
```

```dart
START
`void` Letters =>
  @while (0) {
    [a-zA-Z]
  }
END
```

Examples of repetitions of at least 1 and no limit on the maximum number of repetitions.

```dart
START
`List<int>` Letters =>
  @while (1) {
    [a-zA-Z]
  }
END
```

```dart
START
`void` Letters =>
  @while (1) {
    [a-zA-Z]
  }
END
```

Examples of repetitions of not less than 2 and not more than 3 repetitions.

```dart
START
`List<int>` Letters =>
  @while (2, 3) {
    [a-zA-Z]
  }
END
```

```dart
START
`void` Letters =>
  @while (2, 3) {
    [a-zA-Z]
  }
END
```

Examples of 4 repetitions.

```dart
START
`List<int>` Letters =>
  @while (4, 4) {
    [a-zA-Z]
  }
END
```

```dart
START
`void` Letters =>
  @while (4, 4) {
    [a-zA-Z]
  }
END
```

## Semantic values

Semantic values ​​are the values ​​formed by parsing expressions.  
Semantic values ​​are used to produce parsing results.  
The syntax for using semantic values ​​is as follows.

```txt
v = e
```

```txt
v = `type` e
```

Where `v` is a semantic value, `e` is a parsing expression and `type` is a native type.

An example of the use of semantic value.

```dart
START
`Sting` Digit =>
  n = [0-9]
  $ = { n - 48 }
END
```

## Parsing case-insensitive data

For the case when the result value is not important.

```dart
START
`void` For =>
  [fF][oO][rR]
END
```

For the case when the result value is not very important.

```dart
START
`String` For =>
  [fF][oO][rR]
  $ = `const` { 'FOR' }
END
```

For the case when the result value is important.

```dart
START
`String` For =>
  $ = <[fF][oO][rR]>
END
```

## Parsing data from files

To implement data parsing from files, it is necessary to extend the `State` class.  
The following class members must be overridden:

- `charSize`
- `indexOf`
- `length`
- `peek`
- `startsWith`
- `strlen`
- `substring`

When generating a parser, need specify `InputType.file` as the value of the `inputType` parameter.

## Examples of generated errors

A small program in the file [example/example_json_errors.dart](https://github.com/mezoni/smart_parser/blob/main/example/example_json_errors.dart) demonstrates what errors can be generated by a fairly simple JSON parser.

```txt
----------------------------------------
Source: "string
FormatException: line 1, column 8: Expected: '"'
  ╷
1 │ "string
  │        ^
  ╵
----------------------------------------
Source: {"key" : "value"
FormatException: line 1, column 17: Expected: ',', '}'
  ╷
1 │ {"key" : "value"
  │                 ^
  ╵
----------------------------------------
Source: [0, ]
FormatException: line 1, column 5: Expected: '"', '[', 'false', 'null', 'number', 'true', '{'
  ╷
1 │ [0, ]
  │     ^
  ╵
----------------------------------------
Source: [0, 1
FormatException: line 1, column 6: Expected: ',', ']'
  ╷
1 │ [0, 1
  │      ^
  ╵
----------------------------------------
Source: -
FormatException: line 1, column 1: Unterminated number
  ╷
1 │ -
  │ ^
  ╵
----------------------------------------
Source: 1.
FormatException: line 1, column 3: Fractional part is missing a number
  ╷
1 │ 1.
  │   ^
  ╵
----------------------------------------
Source: 1E
FormatException: line 1, column 3: Exponent part is missing a number
  ╷
1 │ 1E
  │   ^
  ╵
----------------------------------------
Source: "\
FormatException: line 1, column 3: Expected: 'escape character'
  ╷
1 │ "\
  │   ^
  ╵
----------------------------------------
Source: "\z
FormatException: line 1, column 3: Illegal escape character
  ╷
1 │ "\z
  │   ^
  ╵
----------------------------------------
Source: "\u
FormatException: line 1, column 4: Expected: '4 hexadecimal digit number'
  ╷
1 │ "\u
  │    ^
  ╵
----------------------------------------
Source: "\u00
FormatException: line 1, column 6: Expected hexadecimal digit
  ╷
1 │ "\u00
  │      ^
  ╵
line 1, column 4: Unterminated 4 hexadecimal digit number
  ╷
1 │ "\u00
  │    ^^
  ╵
```
