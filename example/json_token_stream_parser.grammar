%{
import 'package:source_span/source_span.dart';

import 'json_ast.dart';
import 'json_token.dart';
import 'json_tokenizer.dart';

JsonValue parse(String source) {
  final tokens = tokenize(source);
  final parser = JsonParser(tokens);
  final state = State('');
  final result = parser.parseStart(state);
  if (result == null) {
    final file = SourceFile.fromString(source);
    final message = state
        .getErrors()
        .map((e) => file.span(e.start, e.end).message(e.message))
        .join('\n');
    throw FormatException('\n$message');
  }

  return result.$1;
}
}%

%%
  Token token;

  int index = 0;

  final List<Token> _tokens;

  JsonParser(List<Token> tokens)
    : _tokens = tokens,
      token = tokens.isEmpty
          ? throw ArgumentError('Must not be empty', 'tokens')
          : tokens.first;

  /// Advances the parsing position to the next token, if possible.
  /// Sets this token as the current token.
  /// Returns the token that was current when this method was called.
  Token nextToken(State state) {
    final token = this.token;
    if (index < _tokens.length) {
      this.token = _tokens[++index];
      final start = this.token.start;
      state.position = start;
      if (state.farthestPosition < start) {
        state.farthestPosition = start;
      }
    }

    return token;
  }

  /// Restores the current token.
  void restoreToken(State state, int index) {
    this.index = index;
    token = _tokens[index];
    state.position = token.start;
  }
%%

`JsonValue` Start =>
  $ = Value
  & { token.kind == TokenKind.eof }
  ~{ state.errorExpected('enf of file'); }

`List<JsonCollectionElement<JsonValue>>` Elements =>
  value = Value
  { final list = [JsonCollectionElement(null, value)]; }
  @while (0) {
    comma = comma
    ~{ state.errorExpected(','); }
    value = Value
    { list.add(JsonCollectionElement(comma, value)); }
  }
  $ = { list }

`JsonArray` Array =>
  openBracket = openBracket
  elements = Elements?
  closeBracket = closeBracket
  ~{ state.errorExpected(']'); }
  $ = { JsonArray(openBracket, elements?? [], closeBracket) }

`JsonKeyValuePair` KeyValuePair =>
  string = String
  ~{ state.errorExpected('string'); }
  colon = colon
  ~{ state.errorExpected(':'); }
  value = Value
  $ = { JsonKeyValuePair(string, colon, value) }

`List<JsonCollectionElement<JsonKeyValuePair>>` KeyValuePairs =>
  keyValuePair = KeyValuePair
  { final list = [JsonCollectionElement(null, keyValuePair)]; }
  @while (0) {
    comma = comma
    ~{ state.errorExpected(','); }
    keyValuePair = KeyValuePair
    { list.add(JsonCollectionElement(comma, keyValuePair)); }
  }
  $ = { list }

`JsonObject` Object =>
  openBrace = openBrace
  elements = KeyValuePairs?
  closeBrace = closeBrace
  ~{ state.errorExpected('\u007D'); }
  $ = { JsonObject(openBrace, elements ?? [], closeBrace) }

`JsonString` String =>
  string = string
  $ = { JsonString(string) }

`JsonValue` Value =>
  (
    $ = String
    ----
    number = number
    $ = { JsonNumber(number) }
    ----
    nullKeyword = nullKeyword
    $ =  { JsonNull(nullKeyword) }
    ----
    trueKeyword = trueKeyword
    $ = { JsonBoolean(trueKeyword) }
    ----
    falseKeyword = falseKeyword
    $ = { JsonBoolean(falseKeyword) }
    ----
    & openBrace
    $ = Object
    ----
    & openBracket
    $ = Array
  )
  ~{ state.errorExpected(const ['string', 'number', 'array', 'object', 'null', 'boolean value']); }