%{
import 'package:source_span/source_span.dart';

import 'json_token.dart';

List<Token> tokenize(String source) {
  const tokenizer = JsonTokenizer();
  final state = State(source);
  final result = tokenizer.parseStart(state);
  if (result == null) {
    final file = SourceFile.fromString(source);
    final message = state
        .getErrors()
        .map((e) => file.span(e.start, e.end).message(e.message))
        .join('\n');
    throw FormatException('\n$message');
  }

  return result.$1;
}
}%

%%
const JsonTokenizer();

Token _token(int start, int end, TokenKind kind, Object? value) {
  return Token(start: start, end: end, kind: kind, value: value);
}
%%

`List<Token>` Start =>
  t = Tokens
  & { state.ch < 0 }
  {
    final eof = _token(state.position, state.position, TokenKind.eof, null);
    t.add(eof);
  }
  $ = { t }


`List<Token>` Tokens =>
  $ = (
    S
    $ = (
      { final int start = state.position; }
      ":"
      $ = { _token(start, state.position, TokenKind.colon, ':') }
      ----
      ","
      $ = { _token(start, state.position, TokenKind.comma, ',') }
      ----
      "{"
      $ = { _token(start, state.position, TokenKind.openBrace, '\u007B') }
      ----
      "}"
      $ = { _token(start, state.position, TokenKind.closeBrace, '\u007D') }
      ----
      "["
      $ = { _token(start, state.position, TokenKind.openBracket, '[') }
      ----
      "]"
      $ = { _token(start, state.position, TokenKind.closeBracket, ']') }
      ----
      "null"
      $ = { _token(start, state.position, TokenKind.nullKeyword, null) }
      ----
      "true"
      $ = { _token(start, state.position, TokenKind.trueKeyword, true) }
      ----
      "false"
      $ = { _token(start, state.position, TokenKind.falseKeyword, false) }
      ----
      &["]
      string = String
      $ = { _token(start, state.position, TokenKind.string, string) }
      ----
      number = Number
      $ = { _token(start, state.position, TokenKind.number, number) }
    )
  )*
  S

`String` EscapeC =>
  (
    ["]
    $ = `const` { '"' }
    ----
    [\\]
    $ = `const` { '\\' }
    ----
    [/]
    $ = `const` { '/' }
    ----
    [b]
    $ = `const` { '\b' }
    ----
    [f]
    $ = `const` { '\f' }
    ----
    [n]
    $ = `const` { '\n' }
    ----
    [r]
    $ = `const` { '\r' }
    ----
    [t]
    $ = `const` { '\t' }
  )
  ~{
    if (state.position == state.length) {
      state.errorExpected('escape character');
    } else {
      state.error('Illegal escape character');
    }
  }

`String` EscapeUnicode =>
  { final start = state.position; }
  "u"
  { var end = 0; }
  text = <
    @while (4, 4) {
      [a-fA-F0-9]
      ~{
        end = state.position;
        state.errorExpected('hexadecimal digit');
      }
    }
  >
  ~{ state.error('Incorrect Unicode escape sequence', position: end, start: start, end: end); }
  $ = { String.fromCharCode(int.parse(text, radix: 16)) }

`String` Escaped =>
  & "u"
  $ = EscapeUnicode
  ----
  EscapeC

`String` String =>
  { final start = state.position; }
  ["]
  parts = @while (0) {
    <[^{0-1F}"\\]+>
    ---
    [\\]
    $ = Escaped
  }
  ["]
  ~{
    state.error('Unterminated string', start: start);
    state.errorExpected('"');
  }
  S
  $ = { parts.length == 1 ? parts[0] : parts.isNotEmpty ? parts.join() : '' }

`num` Number =>
  {
    final start = state.position;
    var flag = true;
  }
  [-]?
  ([0] / [1-9] [0-9]*)
  ~{ state.errorExpected('digit'); }
  (
    [.]
    [0-9]+
    ~{
      state.errorExpected('digit');
      state.error('Fractional part is missing a number');
      state.error('Malformed number', start: start, end: state.position);
    }
    { flag = false; }
  )?
  (
    [eE]
    [\-+]?
    [0-9]+
    ~{
      state.errorExpected('digit');
      state.error('Exponent part is missing a number');
      state.error('Malformed number', start: start, end: state.position);
    }
    { flag = false; }
  )?
  text = { state.substring(start, state.position) }
  S
  $ = { flag && text.length <= 18 ? int.parse(text) : num.parse(text) }

`void` S =>
  [\n\r\t ]*