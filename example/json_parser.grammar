%{
import 'package:source_span/source_span.dart';

Object? parse(String source) {
  const parser = JsonParser();
  final state = State(source);
  final result = parser.parseStart(state);
  if (result == null) {
    final file = SourceFile.fromString(source);
    final message = state
        .getErrors()
        .map((e) => file.span(e.start, e.end).message(e.message))
        .join('\n');
    throw FormatException('\n$message');
  }

  return result.$1;
}
}%

%%
const JsonParser();
%%

`Object?` Start =>
  S
  $ = Value
  & { state.ch < 0 }
  ~{ state.errorExpected('enf of file'); }

`List<Object?>` Elements =>
  value = Value
  { final elements = [value]; }
  @while (0) {
    ',' S
    value = Value
    { elements.add(value); }
  }
  $ = { elements }

`List<Object?>` Array =>
  "[" S
  elements = Elements?
  ']' S
  $ = { elements ?? [] }

`MapEntry<String, Object?>` KeyValue =>
  key = String
  ~{ state.errorExpected('string'); }
  ':' S
  value = Value
  $ = { MapEntry(key, value) }

`Map<String, Object?>` Map =>
  keyValue = KeyValue
  {
    final map = <String, Object?>{};
    map[keyValue.key] = keyValue.value;
  }
  @while (0) {
    ',' S
    keyValue = KeyValue
    { map[keyValue.key] = keyValue.value; }
  }
  $ = { map }

`Map<String, Object?>` Object =>
  "{" S
  map = Map?
  '}' S
  $ = { map ?? {} }

`String` EscapeC =>
  (
    ["]
    $ = `const` { '"' }
    ----
    [\\]
    $ = `const` { '\\' }
    ----
    [/]
    $ = `const` { '/' }
    ----
    [b]
    $ = `const` { '\b' }
    ----
    [f]
    $ = `const` { '\f' }
    ----
    [n]
    $ = `const` { '\n' }
    ----
    [r]
    $ = `const` { '\r' }
    ----
    [t]
    $ = `const` { '\t' }
  )
  ~{
    if (state.position == state.length) {
      state.errorExpected('escape character');
    } else {
      state.error('Illegal escape character');
    }
  }

`String` EscapeUnicode =>
  { final start = state.position; }
  "u"
  { var end = 0; }
  text = <
    @while (4, 4) {
      [a-fA-F0-9]
      ~{
        end = state.position;
        state.errorExpected('hexadecimal digit');
      }
    }
  >
  ~{ state.error('Incorrect Unicode escape sequence', position: end, start: start, end: end); }
  $ = { String.fromCharCode(int.parse(text, radix: 16)) }

`String` Escaped =>
  & "u"
  $ = EscapeUnicode
  ----
  EscapeC

`String` String =>
  { final start = state.position; }
  ["]
  parts = @while (0) {
    <[^{0-1F}"\\]+>
    ---
    [\\]
    $ = Escaped
  }
  ["]
  ~{
    state.error('Unterminated string', start: start);
    state.errorExpected('"');
  }
  S
  $ = { parts.length == 1 ? parts[0] : parts.isNotEmpty ? parts.join() : '' }

`num` Number =>
  {
    final start = state.position;
    var flag = true;
  }
  [-]?
  ([0] / [1-9] [0-9]*)
  ~{ state.errorExpected('digit'); }
  (
    [.]
    [0-9]+
    ~{
      state.errorExpected('digit');
      state.error('Fractional part is missing a number');
      state.error('Malformed number', start: start, end: state.position);
    }
    { flag = false; }
  )?
  (
    [eE]
    [\-+]?
    [0-9]+
    ~{
      state.errorExpected('digit');
      state.error('Exponent part is missing a number');
      state.error('Malformed number', start: start, end: state.position);
    }
    { flag = false; }
  )?
  text = { state.substring(start, state.position) }
  S
  $ = { flag && text.length <= 18 ? int.parse(text) : num.parse(text) }

`Object?` Value =>
  (
    "null" S
    $ = `const` { null }
    ----
    "true" S
    $ = `const` { true }
    ----
    "false" S
    $ = `const` { false }
    ----
    & "{"
    $ = Object
    ----
    & "["
    $ = Array
    ----
    & ["]
    $ = String
    ----
    Number
  )
  ~{ state.errorExpected(const ['string', 'number', 'array', 'object', 'null', 'boolean value']); }

  `void` S =>
    [\n\r\t ]*