%{
import 'package:source_span/source_span.dart';

import '../../expressions.dart';
import '../../grammar.dart';

Grammar parse(String source) {
  const parser = TokenStreamParser();
  final state = State(source);
  final result = parser.parseStart(state);
  if (result == null) {
    final file = SourceFile.fromString(source);
    throw FormatException(
      state
          .getErrors()
          .map((e) => file.span(e.start, e.end).message(e.message))
          .join('\n'),
    );
  }

  return result.$1;
}

extension _Ext<T extends Expression> on T {
  T setType(String? type) {
    if (type != null) {
      this.type = type;
    }
    return this;
  }
}
}%

%%
const TokenStreamParser();
%%

`Grammar`
Start =>
  S
  g = Globals?
  m = Members?
  p = Production+
  ! .
  $ = { Grammar(globals: g, members: m, productions: p) }

`String`
Globals =>
  { final start = state.position; }
  "%{"
  { final index = state.indexOf('\u007D%'); }
  $ = <@position({ index == -1 ? state.length : index })>
  "}%" ~{ state.error('Unterminated globals section', position: start); } S

`String`
Members =>
  { final start = state.position; }
  "%%"
  { final index = state.indexOf('%%'); }
  $ = <@position({ index == -1 ? state.length : index })>
  "%%" ~{ state.error('Unterminated members section', position: start); } S

`Production`
Production =>
  { final start = state.position; }
  t = Type
  ~{ state.errorExpected('type'); }
  i = ProductionName
  ~{ state.errorExpected('production name'); }
  '=>' S
  e = Expression
  [;]? S
  {
    final end = state.position;
    final src = state.substring(start, end).trimRight();
  }
  $ = { Production(expression: e, name: i, sourceCode: src, type: t) }

`Expression`
Expression =>
  { final pos = state.position; }
  e = OrderedChoice
  ~{ state.errorExpected('expression'); }
  { e.sourceCode = state.substring(pos, state.position).trimRight(); }
  $ = { e }

`Expression`
OrderedChoice =>
  n = Sequence
  { final l = [n]; }
  @while (0) {
    (
      "/"
      ----
      "-"+
    ) S
    n = Sequence
    { l.add(n); }
  }
  $ = { OrderedChoiceExpression(expressions: l) }

`Expression`
Sequence =>
  { final pos = state.position; }
  n = (
    { final pos = state.position; }
    e = SequenceElement
    h = ErrorHandler?
    { e.sourceCode = state.substring(pos, state.position).trimRight(); }
    $ = `Expression` { e..errorHandler = h }
  )+
  e = { SequenceExpression(expressions: n) }
  { e.sourceCode = state.substring(pos, state.position).trimRight(); }
  $ = { e }

`Expression`
SequenceElement =>
  Action
  ----
  v = (
    $ = SemanticValue
    '=' S
  )?
  t = Type?
  e = Prefix
  {
    e.semanticValue = v;
    e.explicitType = t;
  }
  $ = { e }

`String`
SemanticValue =>
  VariableName
  ---
  $ = '$'
  S

`Expression`
Prefix =>
  "!" S
  $ = (
    b = Block
    $ = { PredicateExpression(negate: true, predicate: b) }
    ----
    s = Suffix
    $ = { NotPredicateExpression(expression: s) }
  )
  ----
  "&" S
  $ = (
    b = Block
    $ = { PredicateExpression(negate: false, predicate: b) }
    ---
    s = Suffix
    $ = { AndPredicateExpression(expression: s) }
  )
  ----
  Suffix

`Expression`
Suffix =>
  p = Primary
  $ = (
    "*" S
    $ = { ZeroOrMoreExpression(expression: p) }
    ----
    "+" S
    $ = { OneOrMoreExpression(expression: p) }
    ----
    "?" S
    $ = { OptionalExpression(expression: p) }
    ---
    ""
    $ = { p }
  )

`Expression`
Primary =>
  (
    Symbol
    ----
    Value
    ----
    Group
    ----
    While
    ---
    Token
  ) ~{ state.errorExpected('expression'); }

`Expression`
Symbol =>
  n = ProductionName S
  ! '=>'
  $ = { ProductionExpression(name: n) }

`Expression`
Action =>
  b = Block
  $ = { ActionExpression(source: b) }

`Expression`
Value =>
  b = Block
  $ = { ValueExpression(source: b) }

`Expression`
Group =>
  t = Type?
  "(" S
  e = Expression
  ')' S
  g = { GroupExpression(expression: e) }
  { t != null ? g.type = t : null; }
  $ = { g }

`Expression`
Token =>
  n = <[$a-z] [$a-zA-Z0-9_]*>
  ~{ state.errorExpected('token name'); }
  S
  $ = { TokenExpression(name: n) }

`Expression`
While =>
  t = Type?
  "@while" S
  '(' S
  r = WhileRange
  ~{ state.errorExpected('while range'); }
  ')' S
  '{' S
  e = Expression
  '}' S
  $ = { WhileExpression(expression: e, range: r).setType(t) }

`(int, int?)`
WhileRange =>
  m = DecValue S
  n = (
    ',' S
    $ = DecValue1 S
  )?
  $ = { (m, n) }

`String`
ErrorHandler =>
  "~" S
  $ = Block

`String`
Type =>
  "`"
  $ = <
    @while (1) {
      ! [`]
      [a-zA-Z0-9_$<(\{,:\})>? ]
    }
  >
  ~{ state.errorExpected('type description'); }
  '`' S

`String`
DQString =>
  "\""
  p = @while (0) {
    <[{20-21}{23-5B}{5D-10FFFF}]+>
    ---
    Escaped
  }
  '"' S
  $ = { p.join() }

`String`
SQString =>
  "'"
  p = @while (0) {
    <[{20-26}{28-5B}{5D-10FFFF}]+>
    ---
    Escaped
  }
  '\'' S
  $ = { p.join() }

`String`
Escaped =>
  "\\"
  $ = (
    "u"
    '{'
    v = HexValue
    ~{ state.error('unicode escape'); }
    '}'
    ~{ state.error('Unterminated Unicode escape sequence'); }
    $ = {String.fromCharCode(v) }
    ----
    "a"
    $ = `const` { '\u0007' }
    ----
    "b"
    $ = `const` { '\b' }
    ----
    "e"
    $ = `const` { '\u001B' }
    ----
    "f"
    $ = `const` { '\f' }
    ----
    "n"
    $ = `const` { '\n' }
    ----
    "r"
    $ = `const` { '\r' }
    ----
    "t"
    $ = `const` { '\t' }
    ----
    "v"
    $ = `const` { '\v' }
    ----
    "\\"
    $ = `const` { '\\' }
    ----
    "\""
    $ = `const` { '"' }
    ----
    "'"
    $ = `const` { '\'' }
  )
  ~{state.error('Illegal escape character'); }

`int`
DecValue =>
  n = <[0-9]+>
  ~{ state.errorExpected('decimal number'); }
  $ = { int.parse(n) }

`int`
DecValue1 =>
  n = <[1-9] [0-9]*>
  ~{ state.errorExpected('decimal number from 1'); }
  $ = { int.parse(n) }

`int`
HexValue =>
  n = <[a-fA-F0-9]+>
  ~{ state.errorExpected('hexadecimal number'); }
  $ = { int.parse(n, radix: 16) }

`String`
Block =>
  "{"
  $ = <BlockBody*>
  '}' S

`void`
BlockBody =>
  "{"
  BlockBody*
  '}'
  ----
  ! "}"
  .

`String`
VariableName =>
  $ = <[a-z] [a-zA-Z0-9_]*>
  S

`String`
ProductionName =>
  $ = <[A-Z] [a-zA-Z0-9_]*>
  S

`void`
S => @while (0) {
  Space
  ----
  Comment
}

`void`
Comment =>
  "#"
  @while (0) {
    ! EndOfLine
    .
  }
  EndOfLine?

`void`
Space =>
  [ \t]
  ----
  EndOfLine

`void`
EndOfLine =>
  "\r\n"
  ----
  [\n\r]