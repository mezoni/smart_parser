%{
import 'package:source_span/source_span.dart';

import '../../expressions.dart';
import '../../grammar.dart';

Grammar parse(String source) {
  const parser = TextParser();
  final state = State(source);
  final result = parser.parseStart(state);
  if (result == null) {
    final file = SourceFile.fromString(source);
    final message = state
        .getErrors()
        .map((e) => file.span(e.start, e.end).message(e.message))
        .join('\n');
    throw FormatException('\n$message');
  }

  return result.$1;
}
}%

%%
const TextParser();
%%

`Grammar`
Start =>
  S
  globals = Globals?
  members = Members?
  productions = Production+
  !.
  ~ { state.errorExpected('end of file'); }
  $ = { Grammar(globals: globals, members: members, productions: productions) }

`String`
Globals =>
  { final start = state.position; }
  "%{"
  { final index = state.indexOf('\u007D%'); }
  $ = <@position({ index == -1 ? state.length : index })>
  "}%"
  ~{ state.error('Unterminated globals section', position: start); } S

`String`
Members =>
  { final start = state.position; }
  "%%"
  { final index = state.indexOf('%%'); }
  $ = <@position({ index == -1 ? state.length : index })>
  "%%"
  ~{ state.error('Unterminated members section', position: start); } S

`Production`
Production =>
  { final start = state.position; }
  type = Type
  ~{ state.errorExpected('type'); }
  name = ProductionName
  ~{ state.errorExpected('production name'); }
  '=>' S
  expression = Expression
  [;]? S
  {
    final end = state.position;
    final source = state.substring(start, end).trimRight();
  }
  $ = { Production(expression: expression, name: name, sourceCode: source, type: type) }

`Expression`
Expression =>
  { final pos = state.position; }
  expression = OrderedChoice
  ~{ state.errorExpected('expression'); }
  { expression.sourceCode = state.substring(pos, state.position).trimRight(); }
  $ = { expression }

`Expression`
OrderedChoice =>
  expression = Sequence
  { final expressions = [expression]; }
  @while (0) {
    (
      "/"
      ----
      "-"+
    ) S
    expression = Sequence
    { expressions.add(expression); }
  }
  $ = { OrderedChoiceExpression(expressions: expressions) }

`Expression`
Sequence =>
  { final pos = state.position; }
  expressions = (
    { final pos = state.position; }
    expression = SequenceElement
    errorHandler = ErrorHandler?
    { expression.sourceCode = state.substring(pos, state.position).trimRight(); }
    $ = `Expression` { expression..errorHandler = errorHandler }
  )+
  expression = { SequenceExpression(expressions: expressions) }
  { expression.sourceCode = state.substring(pos, state.position).trimRight(); }
  $ = { expression }

`Expression`
SequenceElement =>
  Action
  ----
  semanticValue = (
    $ = SemanticValue
    '=' S
  )?
  type = Type?
  expression = Prefix
  {
    expression.semanticValue = semanticValue;
    expression.explicitType = type;
  }
  $ = { expression }

`String`
SemanticValue =>
  VariableName
  ---
  $ = '$'
  S

`Expression`
Prefix =>
  "!" S
  $ = (
    source = Block
    $ = { PredicateExpression(negate: true, source: source) }
    ----
    expression = Suffix
    $ = { NotPredicateExpression(expression: expression) }
  )
  ----
  "&" S
  $ = (
    source = Block
    $ = { PredicateExpression(negate: false, source: source) }
    ---
    expression = Suffix
    $ = { AndPredicateExpression(expression: expression) }
  )
  ----
  Suffix

`Expression`
Suffix =>
  expression = Primary
  $ = (
    "*" S
    $ = { ZeroOrMoreExpression(expression: expression) }
    ----
    "+" S
    $ = { OneOrMoreExpression(expression: expression) }
    ----
    "?" S
    $ = { OptionalExpression(expression: expression) }
    ---
    ""
    $ = { expression }
  )

`Expression`
Primary =>
  (
    Symbol
    ---
    Value
    ----
    CharacterClass
    ----
    Literal
    ----
    Group
    ----
    While
    ----
    AnyCharacter
    ----
    Capture
    ----
    Position
    ----
    Match
  )
  ~{ state.errorExpected('expression'); }

`Expression`
Symbol =>
  name = ProductionName S
  !'=>'
  $ = { ProductionExpression(name: name) }

`Expression`
Action =>
  source = Block
  $ = { ActionExpression(source: source) }

`Expression`
Value =>
  source = Block
  $ = { ValueExpression(source: source) }

`Expression`
AnyCharacter =>
  "." S
  $ = { AnyCharacterExpression() }

`Expression`
Capture =>
  "<" S
  expression = Expression
  '>' S
  $ = { CaptureExpression(expression: expression) }

`Expression`
CharacterClass =>
  { var negate = false; }
  (
    "[^"
    { negate = true; }
    ----
    "["
  )
  ranges = @while (1) {
    ! "]"
    $ = Range
  } ~{ state.errorExpected('characters'); }
  ']' S
  $ = { CharacterClassExpression(ranges: ranges, negate: negate) }

`Expression`
Group =>
  "(" S
  expression = Expression
  ')' S
  $ = { GroupExpression(expression: expression) }

`Expression`
Literal =>
  text = SQString
  $ = { LiteralExpression(text: text) }
  ----
  text = DQString
  $ = { LiteralExpression(isPrimitive: true, text: text) }

`Expression`
Match =>
  "@match" S
  '(' S
  { var quote = '\''; }
  text = (
    SQString
    ---
    $ = DQString
    { quote = '"'; }
  )
  ~{ state.errorExpected('string value'); }
  ')' S
  $ = { MatchExpression(quote: quote, text: text) }

`Expression`
Position =>
  "@position" S
  '(' S
  action = Block
  ~{ state.errorExpected('position value'); }
  ')' S
  $ = { PositionExpression(action: action) }

`Expression`
While =>
  "@while" S
  '(' S
  range = WhileRange
  ~{ state.errorExpected('while range'); }
  ')' S
  '{' S
  expression = Expression
  '}' S
  $ = { WhileExpression(expression: expression, range: range) }

`(int, int?)`
WhileRange =>
  min = DecValue S
  max = (
    ',' S
    $ = DecValue1 S
  )?
  $ = { (min, max) }

`String`
ErrorHandler =>
  "~" S
  $ = Block

`String`
Type =>
  "`"
  $ = <
    @while (1) {
      ! [`]
      [a-zA-Z0-9_$<(\{,:\})>? ]
    }
  >
  ~{ state.errorExpected('type description'); }
  '`' S

`String`
DQString =>
  "\""
  parts = @while (0) {
    <[{20-21}{23-5B}{5D-10FFFF}]+>
    ---
    Escaped
  }
  '"' S
  $ = { parts.join() }

`String`
SQString =>
  "'"
  parts = @while (0) {
    <[{20-26}{28-5B}{5D-10FFFF}]+>
    ---
    Escaped
  }
  '\'' S
  $ = { parts.join() }

`String`
Escaped =>
  "\\"
  $ = (
    "u"
    '{'
    charCode = HexValue
    ~{ state.error('unicode escape'); }
    '}'
    ~{ state.error('Unterminated Unicode escape sequence'); }
    $ = { String.fromCharCode(charCode) }
    ----
    "a"
    $ = `const` { '\u0007' }
    ----
    "b"
    $ = `const` { '\b' }
    ----
    "e"
    $ = `const` { '\u001B' }
    ----
    "f"
    $ = `const` { '\f' }
    ----
    "n"
    $ = `const` { '\n' }
    ----
    "r"
    $ = `const` { '\r' }
    ----
    "t"
    $ = `const` { '\t' }
    ----
    "v"
    $ = `const` { '\v' }
    ----
    "\\"
    $ = `const` { '\\' }
    ----
    "\""
    $ = `const` { '"' }
    ----
    "'"
    $ = `const` { '\'' }
  )
  ~{ state.error('Illegal escape character'); }

`int`
RangeChar =>
  ! "\\"
  $ = [^{0-1F}\{\}\[\]\\]
  ---
  "\\"
  $ = (
    "u"
    '{'
    $ = HexValue
    ~{ state.errorExpected('hex number'); }
    '}'
    ----
    "a"
    $ = `const` { 0x07 }
    ---
    "b"
    $ = `const` { 0x08 }
    ---
    "e"
    $ = `const` { 0x1B }
    ---
    "f"
    $ = `const` { 0x0C }
    ---
    "n"
    $ = `const` { 0x0A }
    ---
    "r"
    $ = `const` { 0x0D }
    ---
    "t"
    $ = `const` { 0x09 }
    ---
    "v"
    $ = `const` { 0x0B }
    ---
    "-"
    $ = `const` { 0x2D }
    ---
    "["
    $ = `const` { 0x5B }
    ---
    "\\"
    $ = `const` { 0x5C }
    ---
    "]"
    $ = `const` { 0x5D }
    ---
    "^"
    $ = `const` { 0x5E }
    ---
    "{"
    $ = `const` { 0x7B }
    ---
    "}"
    $ = `const` { 0x7D }
  )
  ~{ state.error('Illegal escape character'); }

`int`
DecValue =>
  text = <[0-9]+>
  ~{ state.errorExpected('decimal number'); }
  $ = { int.parse(text) }

`int`
DecValue1 =>
  text = <[1-9] [0-9]*>
  ~{ state.errorExpected('decimal number from 1'); }
  $ = { int.parse(text) }

`int`
HexValue =>
  text = <[a-fA-F0-9]+>
  ~{ state.errorExpected('hexadecimal number'); }
  $ = { int.parse(text, radix: 16) }

`(int, int)`
Range =>
  (
    "{"
    start = HexValue
    '-'
    end = HexValue
    '}'
    $ = { (start, end) }
    ----
    "{"
    char = HexValue
    '}'
    $ = { (char, char) }
    ---
    start = RangeChar
    '-'
    end = RangeChar
    $ = { (start, end) }
    ----
    char = RangeChar
    $ = { (char, char) }
  )

`String`
Block =>
  "{"
  $ = <BlockBody*>
  '}' S

`void`
BlockBody =>
  "{"
  BlockBody*
  '}'
  ----
  !"}"
  .

`String`
VariableName =>
  $ = <[a-z] [a-zA-Z0-9_]*>
  S

`String`
ProductionName =>
  $ = <[A-Z] [a-zA-Z0-9_]*>
  S

`void` S =>
  @while (0) {
    Space
    ----
    Comment
  }

`void`
Comment =>
  "#"
  @while (0) {
    !EndOfLine
    .
  }
  EndOfLine?

`void`
Space =>
  [ \t]
  ----
  EndOfLine

`void`
EndOfLine =>
  "\r\n"
  ----
  [\n\r]